// 主要分三个模块: apply plugin , android, dependencies

// apply plugin: 声明了接下来要用到哪些插件的内容 (需要在主目录build.gradle文件中添加依赖)
apply plugin: 'com.android.application'     // android插件
apply plugin: 'kotlin-android'              // kotlin 插件
apply plugin: 'kotlin-android-extensions'   // kotlin 扩展插件

android {

    compileSdkVersion 26        // 编译应用的 Android API 版本
    /*buildToolsVersion '26.0.2'*/  // 构建工具版本 (可省略?)

    // 配置应用的默认属性，可以覆盖 AndroidManifest.xml 中的属性
    defaultConfig {
        applicationId "com.linsh.app"  // 覆盖了AndroidManifest中的package name (覆盖了应用唯一标识的属性)
        minSdkVersion 15        // 配置运行应用的最小 API
        targetSdkVersion 26     // 用于通知系统当前应用已经被这个版本测试过
        versionCode 1           // 应用的版本号
        versionName "1.0"       // 版本名称
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
        // 还可以添加签名，占位符等等
    }

    // 用来定义如何构建和打包不同类型的应用，常见的就是测试和生产
    buildTypes {
        debug {
            // 自定义生成或修改 BuildConfig 的字段 (Sync之后就有了)
            buildConfigField "boolean", "MyConfig", "true"
            // 生成resource文件(strings.xml的值), 可在AndroidManifest中引用@string/app_name2
            /*resValue "string", "app_name2", "LshKnowledgeDebug2"*/
            /*manifestPlaceholders = [app_name: "LshKnowledgeDebug1"]*/ // 替换AndroidManifest中定义的变量, 如: ${app_name}

            debuggable true         // 是否支持调试
            jniDebuggable true      // 是否支持jni调试
            zipAlignEnabled false   // 是否支持Zip Align
            minifyEnabled false     // 是否去除无用的资源
            shrinkResources false   // 打开资源压缩
        }

        release {
            debuggable false
            jniDebuggable false
            zipAlignEnabled true
            minifyEnabled true
            shrinkResources true

            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'  // 混淆文件的指定

            // 以下在 release 环境下生成对应的变量, 以和 debug 环境产生区别
            /*resValue "string", "app_name2", "LshKnowledge2"*/
            /*manifestPlaceholders = [app_name: "LshKnowledge1"]*/
        }
    }

// 已过时?
//// android中还可以配置其他信息，比如 签名、渠道等 ////
// 不同定制的产品
//    productFlavors {
//        yingyongbao {}
//        xiaomi {}
//        huawei {}
//        other {}
//    }
//
//    productFlavors.all {
//            // 根据 flavor 替换清单文件的渠道名属性
//        flavor ->
//            flavor.manifestPlaceholders = [ONEAPM_CHANNEL_VALUE: name] // 替换 ONEAPM 渠道名 (多渠道打包)
//    }
}

repositories {
    flatDir {
        // 导入 libs 中的 jar包和 aar包
        dirs 'libs'
        // 如果依赖的 Module 中存在 aar包, 需要在这里配置具体的 aar 路径, 否则会找不到
        dirs '../library/libs'
    }
}

/// 依赖传递 & 依赖排除 & 使用强制版本 的全局配置///
configurations.all {
    // transitive = false 时, 表示全局关闭依赖传递, 即不再依赖该 Module 中依赖库中的依赖 (一般很少用)
    /*transitive = false*/
    // 编译期排除依赖传递: 指定模块
    /*compile.exclude module: 'library'*/
    // 排除依赖传递: 指定库
    /*all*.exclude group: 'com.android.support', module: 'appcompat-v7'*/
    // 使用强制版本: 冲突时优先使用该版本进行解决
    /*resolutionStrategy {
        force 'org.hamcrest:hamcrest-core:1.3'
    }*/
}

// 依赖配置
dependencies {
    // compile 和 implementation & api 的关系
    // AS 3.0 之后, compile 被标注为过时, 可用 api 指令代替. 同时尽量优先使用 implementation, 因为它会使编译速度有所增快
    // implementation 的不同在于它该依赖库所依赖的依赖库不再对外部公开, 即无法直接使用 LshUtils 里面的依赖库的类, 如: Gson, OkHttp 等
    // 目前使用的建议是: 优先使用 implementation, 如果有错，则使用 api 指令

    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation 'com.android.support:appcompat-v7:26.1.0'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.1'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'

    /// 依赖传递 & 依赖排除 & 使用强制版本 ///
    implementation('com.android.support.constraint:constraint-layout:1.0.2') {
        // 依赖传递: 是否传递 Utils-Everywhere 中的依赖库, 默认为 true; false 为不依赖 Utils-Everywhere 中的依赖库
        transitive = true
        // 依赖排除: 不传递 Utils-Everywhere 中指定的依赖
        /*exclude group: 'org.unwanted', module: 'iAmBuggy'*/
        /*exclude module: 'share'*/
        // 使用强制版本: 冲突时优先使用该版本进行解决
        /*force = true*/
    }
    // 也可以采用添加@jar的方式忽略该依赖的所有传递性依赖 (但可能会导致没有资源? 然后就 @aar?)
    /*compile 'com.github.SenhLinsh:Utils-Everywhere:2.0.0@jar'*/

    // 使用动态版本: 可以让工程使用依赖最新版本
    // 不推荐使用, 它会降低你系统构建的速度同时提高构建失败的风险
    // 因为Gradle不得不每次检查远程仓库是否存在最新版本，同时新版本也可能带来无法预知的兼容性问题
    /*compile 'com.github.SenhLinsh:LshPercentLayout:+'*/

    implementation project(':code')
}

/*
* 依赖冲突 的解决:
* 1. 依赖冲突时，如果有两个依赖引用了相同jar包的不同版本时，默认情况下 gradle 会采用最新版本的 jar包
* 2. 可通过排除选项来排除
*/
